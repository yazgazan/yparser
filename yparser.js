// Generated by CoffeeScript 1.6.2
(function() {
  var AstParser, ExtendedParser, GrammarParser, SimpleParser, YParser, fs,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof require !== "undefined" && require !== null) {
    fs = require('fs');
  }

  SimpleParser = (function() {
    function SimpleParser() {
      this.buffer = '';
      this.pos = 0;
      this.captures = new Object;
      return;
    }

    SimpleParser.prototype.loadString = function(str) {
      this.buffer = str;
      this.pos = 0;
      return true;
    };

    SimpleParser.prototype.peekChar = function(c) {
      if (this.isEnd()) {
        false;
      }
      return this.buffer[this.pos] === c;
    };

    SimpleParser.prototype.peekRange = function(a, b) {
      if (this.isEnd()) {
        false;
      }
      if (a > b) {
        throw "peekRange, invalid range";
      }
      return (this.buffer[this.pos] >= a) && (this.buffer[this.pos] <= b);
    };

    SimpleParser.prototype.peekText = function(str) {
      var end, start;

      if (!(this.inRange(this.pos + str.length - 1))) {
        return false;
      }
      start = this.pos;
      end = this.pos + str.length;
      if (str === this.buffer.slice(start, end)) {
        return true;
      }
      return false;
    };

    SimpleParser.prototype.peekUntil = function(c) {
      var i;

      i = this.pos;
      while (this.inRange(i)) {
        if (this.buffer[i] === c) {
          return i - this.pos;
        }
        i++;
      }
      return false;
    };

    SimpleParser.prototype.peekAlpha = function() {
      return (this.peekRange('a', 'z')) || (this.peekRange('A', 'Z'));
    };

    SimpleParser.prototype.peekNum = function() {
      return this.peekRange('0', '9');
    };

    SimpleParser.prototype.peekAlphaNum = function() {
      return this.peekAlpha() || this.peekNum();
    };

    SimpleParser.prototype.peekSpace = function() {
      return (this.peekChar(' ')) || (this.peekChar('\t'));
    };

    SimpleParser.prototype.peekAnySpace = function() {
      return (this.peekSpace()) || (this.peekText("\r\n")) || (this.peekChar('\n'));
    };

    SimpleParser.prototype.peekAny = function() {
      return !this.isEnd();
    };

    SimpleParser.prototype.consume = function(n) {
      if (!this.inRange(this.pos + n - 1)) {
        throw "Can't consume '" + n + "' chars";
      }
      return this.pos += n;
    };

    SimpleParser.prototype.inRange = function(offset) {
      return offset < this.buffer.length;
    };

    SimpleParser.prototype.isEnd = function() {
      return this.pos === this.buffer.length;
    };

    SimpleParser.prototype.remaining = function() {
      return this.buffer.slice(this.pos);
    };

    SimpleParser.prototype.readChar = function(c) {
      if (!this.peekChar(c)) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readEOF = function() {
      return this.isEnd();
    };

    SimpleParser.prototype.readEOL = function() {
      return (this.readText("\r\n")) || (this.readChar('\n'));
    };

    SimpleParser.prototype.readRange = function(a, b) {
      if (!this.peekRange(a, b)) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readText = function(str) {
      if (!this.peekText(str)) {
        return false;
      }
      this.consume(str.length);
      return true;
    };

    SimpleParser.prototype.readUntil = function(c) {
      var n;

      n = this.peekUntil(c);
      if (n === false) {
        return false;
      }
      this.consume(n);
      return true;
    };

    SimpleParser.prototype.readAny = function() {
      if (!this.peekAny()) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readAlpha = function() {
      if (!this.peekAlpha()) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readNum = function() {
      if (!this.peekNum()) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readAlphaNum = function() {
      if (!this.peekAlphaNum()) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readSpace = function() {
      if (!this.peekSpace()) {
        return false;
      }
      this.consume(1);
      return true;
    };

    SimpleParser.prototype.readAnySpace = function() {
      if (this.peekSpace() || this.peekChar('\n')) {
        this.consume(1);
        return true;
      }
      if (this.peekText("\r\n")) {
        this.consume(2);
        return true;
      }
      return false;
    };

    SimpleParser.prototype.readAll = function(c) {
      var i;

      i = 0;
      while (this.readChar(c)) {
        i++;
      }
      if (i === 0) {
        return false;
      }
      return true;
    };

    SimpleParser.prototype.readIdentifier = function() {
      if (!(this.readAlpha() || this.readChar('_'))) {
        return false;
      }
      while (this.readAlphaNum() || this.readChar('_')) {
        null;
      }
      return true;
    };

    SimpleParser.prototype.readInteger = function() {
      if (!this.readNum()) {
        return false;
      }
      while (this.readNum()) {
        null;
      }
      return true;
    };

    SimpleParser.prototype.readStr = function() {
      var backupPos;

      backupPos = this.pos;
      if (!this.readChar('"')) {
        return false;
      }
      while (true) {
        if (this.readText("\\\\")) {
          continue;
        }
        if (this.readText("\\\"")) {
          continue;
        }
        if (this.readChar('"')) {
          return true;
        }
        if (this.readEOF()) {
          break;
        }
        this.readAny();
      }
      this.pos = backupPos;
      return false;
    };

    SimpleParser.prototype.beginCapture = function(tag) {
      if (this.readEOF()) {
        return false;
      }
      this.captures[tag] = this.pos;
      return true;
    };

    SimpleParser.prototype.endCapture = function(tag) {
      var end, start;

      if (this.captures[tag] == null) {
        return null;
      }
      if (this.pos === this.captures[tag]) {
        return '';
      }
      start = this.captures[tag];
      end = this.pos;
      return this.buffer.slice(start, end);
    };

    return SimpleParser;

  })();

  ExtendedParser = (function(_super) {
    __extends(ExtendedParser, _super);

    function ExtendedParser() {
      this.grammars = new Object;
      this.repeats = {
        '1': this.execOnce,
        '+': this.execOnceOrMore,
        '*': this.execZeroOrMore,
        '?': this.execOnceOrNot
      };
      this.types = {
        'or': this.execOr,
        'and': this.execAnd,
        'not': this.execNot,
        'sub': this.execSub,
        'any': this.applyAny,
        'all': this.applyAll,
        'char': this.applyChar,
        'text': this.applyText,
        'str': this.applyStr,
        'range': this.applyRange,
        'until': this.applyUntil,
        'alpha': this.applyAlpha,
        'num': this.applyNum,
        'alphanum': this.applyAlphaNum,
        'space': this.applySpace,
        'anyspace': this.applyAnySpace,
        'eof': this.applyEOF,
        'eol': this.applyEOL,
        'id': this.applyId,
        'int': this.applyInt
      };
      ExtendedParser.__super__.constructor.call(this);
    }

    ExtendedParser.prototype.setGrammar = function(name, tree) {
      return this.grammars[name] = tree;
    };

    ExtendedParser.prototype.execGrammar = function(name) {
      var backupPos, ret, tree,
        _this = this;

      backupPos = this.pos;
      if ((typeof name) === 'string') {
        if (this.grammars[name] == null) {
          throw "Can't find grammar for '" + name + "'";
        }
        tree = this.grammars[name];
      } else {
        tree = name;
      }
      if (this.repeats[tree.repeat] == null) {
        throw "unknown repeater '" + tree.repeat + "' " + (JSON.stringify(tree));
      }
      ret = this.repeats[tree.repeat].call(this, tree, function(tree) {
        var backupPos2, ret2;

        backupPos2 = _this.pos;
        if (_this.types[tree.type] == null) {
          throw "unknown type '" + tree.type + "'";
        }
        ret2 = _this.types[tree.type].call(_this, tree);
        if (ret === false) {
          _this.pos = backupPos2;
        }
        return ret2;
      });
      if (ret === false) {
        this.pos = backupPos;
      }
      return ret;
    };

    ExtendedParser.prototype.execOnce = function(tree, cb) {
      return cb(tree);
    };

    ExtendedParser.prototype.execOnceOrMore = function(tree, cb) {
      var backupPos, i;

      backupPos = this.pos;
      i = 0;
      while (cb(tree)) {
        i++;
      }
      if (i === 0) {
        this.pos = backupPos;
        return false;
      }
      return true;
    };

    ExtendedParser.prototype.execZeroOrMore = function(tree, cb) {
      while (cb(tree)) {
        null;
      }
      return true;
    };

    ExtendedParser.prototype.execOnceOrNot = function(tree, cb) {
      cb(tree);
      return true;
    };

    ExtendedParser.prototype.execOr = function(tree) {
      var newPos, node, origPos, ret, _i, _len, _ref;

      origPos = this.pos;
      ret = false;
      _ref = tree.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.type === 'not') {
          newPos = this.pos;
          this.pos = origPos;
          if (this.execGrammar(node)) {
            this.pos = origPos;
            return false;
          }
          this.pos = newPos;
        }
        if ((ret === false) && this.execGrammar(node)) {
          ret = true;
        }
      }
      return ret;
    };

    ExtendedParser.prototype.execAnd = function(tree) {
      var backupPos, node, _i, _len, _ref;

      backupPos = this.pos;
      _ref = tree.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.type === 'not' && this.execGrammar(node)) {
          this.pos = backupPos;
          return false;
        }
        if (!this.execGrammar(node)) {
          this.pos = backupPos;
          return false;
        }
      }
      return true;
    };

    ExtendedParser.prototype.execNot = function(tree) {
      var backupPos, ret;

      backupPos = this.pos;
      ret = this.execOr(tree);
      this.pos = backupPos;
      return ret;
    };

    ExtendedParser.prototype.execSub = function(tree) {
      var ret;

      ret = this.execGrammar(tree.nodes[0]);
      return ret;
    };

    ExtendedParser.prototype.applyAny = function(tree) {
      return this.readAny();
    };

    ExtendedParser.prototype.applyAll = function(tree) {
      return this.readAll(tree.nodes[0]);
    };

    ExtendedParser.prototype.applyChar = function(tree) {
      return this.readChar(tree.nodes[0]);
    };

    ExtendedParser.prototype.applyText = function(tree) {
      return this.readText(tree.nodes[0]);
    };

    ExtendedParser.prototype.applyStr = function(tree) {
      return this.readStr();
    };

    ExtendedParser.prototype.applyRange = function(tree) {
      return this.readRange(tree.nodes[0], tree.nodes[1]);
    };

    ExtendedParser.prototype.applyUntil = function(tree) {
      return this.readUntil(tree.nodes[0]);
    };

    ExtendedParser.prototype.applyAlpha = function(tree) {
      return this.readAlpha();
    };

    ExtendedParser.prototype.applyNum = function(tree) {
      return this.readNum();
    };

    ExtendedParser.prototype.applyAlphaNum = function(tree) {
      return this.readAlphaNum();
    };

    ExtendedParser.prototype.applySpace = function(tree) {
      return this.readSpace();
    };

    ExtendedParser.prototype.applyAnySpace = function(tree) {
      return this.readAnySpace();
    };

    ExtendedParser.prototype.applyEOF = function(tree) {
      return this.readEOF();
    };

    ExtendedParser.prototype.applyEOL = function(tree) {
      return this.readEOL();
    };

    ExtendedParser.prototype.applyId = function(tree) {
      return this.readIdentifier();
    };

    ExtendedParser.prototype.applyInt = function(tree) {
      return this.readInteger();
    };

    return ExtendedParser;

  })(SimpleParser);

  AstParser = (function(_super) {
    __extends(AstParser, _super);

    function AstParser() {
      this.initAst();
      this.triggers = new Object;
      this.curCap = 0;
      this.lastRemaining = null;
      this.nocapmode = false;
      AstParser.__super__.constructor.call(this);
    }

    AstParser.prototype.initAst = function(ast) {
      if (ast == null) {
        ast = null;
      }
      if (ast === null) {
        this.ast = new Object;
        this.ast.nodes = new Array;
      } else {
        this.ast = ast;
      }
      this.astStack = new Array;
      this.astStack.push(this.ast);
      return this.ast;
    };

    AstParser.prototype.loadString = function(str) {
      return AstParser.__super__.loadString.call(this, str);
    };

    AstParser.prototype.loadFile = function(filename, cb) {
      var fileContent,
        _this = this;

      return fileContent = fs.readFile(filename, {
        encoding: 'ascii'
      }, function(err, data) {
        if (err) {
          throw err;
        }
        _this.loadString(data);
        return cb.call(_this);
      });
    };

    AstParser.prototype.register = function(name, fn) {
      return this.triggers[name] = fn;
    };

    AstParser.prototype.topAst = function() {
      return this.astStack.slice(-1)[0];
    };

    AstParser.prototype.execGrammar = function(name) {
      var cap, capToRead, capname, cbAst, newAst, newNode, popWhenDone, res, tree;

      newAst = null;
      cbAst = null;
      popWhenDone = false;
      capToRead = null;
      if ((typeof name) === 'string') {
        if (this.grammars[name] == null) {
          throw "Can't find grammar for '" + name + "'";
        }
        tree = this.grammars[name];
      } else {
        tree = name;
      }
      if (this.nocapmode === true) {
        return AstParser.__super__.execGrammar.call(this, tree);
      }
      if (tree.ast != null) {
        if (this.triggers[tree.ast] == null) {
          newAst = new Object;
          newAst.type = tree.ast;
          newAst.nodes = new Array;
        } else {
          newAst = this.triggers[tree.ast].call(this, this.topAst());
        }
        if ((typeof newAst) === 'function') {
          cbAst = newAst;
        } else if (newAst !== null) {
          popWhenDone = true;
          this.astStack.push(newAst);
        }
      }
      if (tree.cap != null) {
        this.beginCapture("cap_" + this.curCap);
        capToRead = this.curCap;
        this.curCap++;
      }
      res = AstParser.__super__.execGrammar.call(this, tree);
      if ((res === true) && (tree.cap != null)) {
        cap = this.endCapture("cap_" + capToRead);
        if (cap === null) {
          cap = '';
        }
        if (this.lastRemaining !== this.remaining()) {
          if (tree.cap.slice(-1) === '!') {
            capname = tree.cap.slice(0, -1);
            cap = this.removeEscape(cap);
          } else {
            capname = tree.cap;
          }
          if (this.triggers[capname] == null) {
            if (tree.capField === true) {
              this.topAst()[capname] = cap;
            } else {
              newNode = new Object;
              newNode.type = capname;
              newNode.nodes = new Array;
              newNode.nodes.push(cap);
            }
          } else {
            newNode = this.triggers[capname].call(this, this.topAst(), cap);
          }
          this.lastRemaining = this.remaining();
          if ((tree.capField !== true) && newNode !== null) {
            this.topAst().nodes.push(newNode);
          }
        }
      }
      if (cbAst !== null) {
        if (res === true) {
          cbAst.call(this, this.topAst());
        }
      } else if (popWhenDone === true) {
        this.astStack.pop();
        if (res === true) {
          this.topAst().nodes.push(newAst);
        }
      }
      return res;
    };

    AstParser.prototype.removeEscape = function(str) {
      var i, ret;

      str = str.slice(1, -1);
      ret = "";
      i = 0;
      while (i < str.length) {
        if (str[i] === '\\') {
          i++;
          ret += str[i];
        } else {
          ret += str[i];
        }
        ++i;
      }
      return ret;
    };

    AstParser.prototype.execOnce = function(tree, cb) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execOnce.call(this, tree, cb);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execOnce.call(this, tree, cb)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execOnce.call(this, tree, cb);
    };

    AstParser.prototype.execOnceOrMore = function(tree, cb) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execOnceOrMore.call(this, tree, cb);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execOnceOrMore.call(this, tree, cb)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execOnceOrMore.call(this, tree, cb);
    };

    AstParser.prototype.execZeroOrMore = function(tree, cb) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execZeroOrMore.call(this, tree, cb);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execZeroOrMore.call(this, tree, cb)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execZeroOrMore.call(this, tree, cb);
    };

    AstParser.prototype.execOnceOrNot = function(tree, cb) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execOnceOrNot.call(this, tree, cb);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execOnceOrNot.call(this, tree, cb)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execOnceOrNot.call(this, tree, cb);
    };

    AstParser.prototype.execOr = function(tree) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execOr.call(this, tree);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execOr.call(this, tree)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execOr.call(this, tree);
    };

    AstParser.prototype.execAnd = function(tree) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execAnd.call(this, tree);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execAnd.call(this, tree)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execAnd.call(this, tree);
    };

    AstParser.prototype.execNot = function(tree) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execNot.call(this, tree);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execNot.call(this, tree)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execNot.call(this, tree);
    };

    AstParser.prototype.execSub = function(tree) {
      var backupPos;

      if (this.nocapmode === true) {
        return AstParser.__super__.execSub.call(this, tree);
      }
      this.nocapmode = true;
      backupPos = this.pos;
      if ((AstParser.__super__.execSub.call(this, tree)) === false) {
        this.pos = backupPos;
        this.nocapmode = false;
        return false;
      }
      this.pos = backupPos;
      this.nocapmode = false;
      return AstParser.__super__.execSub.call(this, tree);
    };

    return AstParser;

  })(ExtendedParser);

  GrammarParser = (function(_super) {
    __extends(GrammarParser, _super);

    function GrammarParser() {
      GrammarParser.__super__.constructor.call(this);
      this.initGrammar();
    }

    GrammarParser.prototype.initAst = function() {
      var ast;

      ast = {
        type: 'undefined',
        repeat: '1',
        nodes: new Array
      };
      return GrammarParser.__super__.initAst.call(this, ast);
    };

    GrammarParser.prototype.loadString = function(str) {
      this.lastAst = null;
      this.lastCap = null;
      this.capToField = false;
      this.goingForNot = false;
      return GrammarParser.__super__.loadString.call(this, str);
    };

    GrammarParser.prototype.loadGrammar = function() {
      var grammarParser, rule, _i, _len, _ref;

      grammarParser = new AstParser;
      if (!this.execGrammar('main')) {
        return false;
      }
      _ref = this.ast.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        grammarParser.setGrammar(rule.name, rule.nodes[0]);
      }
      return grammarParser;
    };

    GrammarParser.prototype.createNotNode = function() {
      var node;

      node = new Object;
      node.type = 'not';
      node.repeat = '1';
      node.cap = null;
      node.ast = null;
      node.nodes = new Array;
      return node;
    };

    GrammarParser.prototype.initGrammar = function() {
      this.setGrammar('_str', {
        type: 'and',
        repeat: '1',
        nodes: [
          {
            type: 'char',
            repeat: '1',
            nodes: ["'"]
          }, {
            type: 'or',
            repeat: '*',
            nodes: [
              {
                type: 'text',
                repeat: '1',
                nodes: ["\\\\"]
              }, {
                type: 'text',
                repeat: '1',
                nodes: ["\\'"]
              }, {
                type: 'any',
                repeat: '1',
                nodes: []
              }, {
                type: 'not',
                repeat: '1',
                nodes: [
                  {
                    type: 'char',
                    repeat: '1',
                    nodes: ["'"]
                  }
                ]
              }
            ]
          }, {
            type: 'char',
            repeat: '1',
            nodes: ["'"]
          }
        ]
      });
      this.setGrammar('_id', {
        type: 'and',
        repeat: '1',
        nodes: [
          {
            type: 'or',
            repeat: '1',
            nodes: [
              {
                type: 'alpha',
                repeat: '1',
                nodes: []
              }, {
                type: 'char',
                repeat: '1',
                nodes: ['_']
              }
            ]
          }, {
            type: 'or',
            repeat: '*',
            nodes: [
              {
                type: 'alphanum',
                repeat: '1',
                nodes: []
              }, {
                type: 'char',
                repeat: '1',
                nodes: ['_']
              }
            ]
          }
        ]
      });
      this.setGrammar('cap', {
        type: 'and',
        repeat: '1',
        cap: 'cap',
        nodes: [
          {
            type: 'sub',
            repeat: '1',
            nodes: ['_id']
          }, {
            type: 'char',
            repeat: '1',
            nodes: [':']
          }
        ]
      });
      this.setGrammar('capstr', {
        type: 'and',
        repeat: '1',
        cap: 'capstr',
        nodes: [
          {
            type: 'sub',
            repeat: '1',
            nodes: ['_id']
          }, {
            type: 'char',
            repeat: '1',
            nodes: ['!']
          }
        ]
      });
      this.setGrammar('ast', {
        type: 'and',
        repeat: '1',
        cap: 'ast',
        nodes: [
          {
            type: 'sub',
            repeat: '1',
            nodes: ['_id']
          }, {
            type: 'char',
            repeat: '1',
            nodes: ['#']
          }
        ]
      });
      this.setGrammar('keywords', {
        type: 'or',
        repeat: '1',
        nodes: [
          {
            type: 'text',
            repeat: '1',
            nodes: ['anyspace']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['any']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['all']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['alphanum']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['str']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['alpha']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['num']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['space']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['eof']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['eol']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['id']
          }, {
            type: 'text',
            repeat: '1',
            nodes: ['int']
          }
        ]
      });
      this.setGrammar('native_token', {
        type: 'or',
        repeat: '1',
        nodes: [
          {
            type: 'sub',
            repeat: '1',
            cap: 'keyword',
            nodes: ['keywords']
          }, {
            type: 'sub',
            repeat: '1',
            cap: 'id',
            nodes: ['_id']
          }, {
            type: 'sub',
            repeat: '1',
            cap: 'str',
            nodes: ['_str']
          }
        ]
      });
      this.setGrammar('token_separator', {
        type: 'or',
        repeat: '1',
        nodes: [
          {
            type: 'and',
            repeat: '1',
            ast: 'or',
            nodes: [
              {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }, {
                type: 'char',
                repeat: '1',
                nodes: ['|']
              }, {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }
            ]
          }, {
            type: 'and',
            repeat: '1',
            ast: 'not',
            nodes: [
              {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }, {
                type: 'char',
                repeat: '1',
                nodes: ['^']
              }, {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }
            ]
          }, {
            type: 'anyspace',
            repeat: '+',
            ast: 'and',
            nodes: []
          }
        ]
      });
      this.setGrammar('repeater', {
        type: 'or',
        repeat: '1',
        cap: 'repeater',
        nodes: [
          {
            type: 'char',
            repeat: '1',
            nodes: ['?']
          }, {
            type: 'char',
            repeat: '1',
            nodes: ['+']
          }, {
            type: 'char',
            repeat: '1',
            nodes: ['*']
          }
        ]
      });
      this.setGrammar('token_group', {
        type: 'and',
        repeat: '1',
        nodes: [
          {
            type: 'char',
            repeat: '1',
            nodes: ['[']
          }, {
            type: 'anyspace',
            repeat: '*',
            nodes: []
          }, {
            type: 'sub',
            repeat: '1',
            nodes: ['token']
          }, {
            type: 'and',
            repeat: '*',
            nodes: [
              {
                type: 'sub',
                repeat: '1',
                nodes: ['token_separator']
              }, {
                type: 'sub',
                repeat: '1',
                nodes: ['token']
              }
            ]
          }, {
            type: 'anyspace',
            repeat: '*',
            nodes: []
          }, {
            type: 'char',
            repeat: '1',
            ast: 'closing_group',
            nodes: [']']
          }
        ]
      });
      this.setGrammar('token_content', {
        type: 'or',
        repeat: '1',
        nodes: [
          {
            type: 'sub',
            repeat: '1',
            nodes: ['native_token']
          }, {
            type: 'sub',
            repeat: '1',
            ast: 'group',
            nodes: ['token_group']
          }
        ]
      });
      this.setGrammar('capsub', {
        type: 'and',
        repeat: '1',
        nodes: [
          {
            type: 'char',
            repeat: '?',
            cap: 'capfield',
            nodes: ['.']
          }, {
            type: 'or',
            repeat: '1',
            nodes: [
              {
                type: 'sub',
                repeat: '1',
                nodes: ['capstr']
              }, {
                type: 'sub',
                repeat: '1',
                nodes: ['cap']
              }
            ]
          }
        ]
      });
      this.setGrammar('token', {
        type: 'and',
        repeat: '1',
        nodes: [
          {
            type: 'sub',
            repeat: '?',
            nodes: ["capsub"]
          }, {
            type: 'sub',
            repeat: '?',
            nodes: ['ast']
          }, {
            type: 'sub',
            repeat: '1',
            nodes: ['token_content']
          }, {
            type: 'sub',
            repeat: '?',
            nodes: ['repeater']
          }
        ]
      });
      this.setGrammar('rule', {
        type: 'and',
        repeat: '1',
        ast: 'rule',
        nodes: [
          {
            type: 'anyspace',
            repeat: '*',
            nodes: []
          }, {
            type: 'sub',
            repeat: '1',
            nodes: ['token']
          }, {
            type: 'and',
            repeat: '*',
            nodes: [
              {
                type: 'sub',
                repeat: '1',
                nodes: ['token_separator']
              }, {
                type: 'sub',
                repeat: '1',
                nodes: ['token']
              }
            ]
          }, {
            type: 'anyspace',
            repeat: '*',
            nodes: []
          }
        ]
      });
      this.setGrammar('main', {
        type: 'and',
        repeat: '*',
        nodes: [
          {
            type: 'and',
            repeat: '1',
            ast: 'newrule',
            nodes: [
              {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }, {
                type: 'sub',
                repeat: '1',
                cap: 'rulename',
                nodes: ['_id']
              }, {
                type: 'space',
                repeat: '*',
                nodes: []
              }, {
                type: 'text',
                repeat: '1',
                nodes: ["::"]
              }, {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }, {
                type: 'sub',
                repeat: '1',
                ast: 'rulecore',
                nodes: ['rule']
              }, {
                type: 'anyspace',
                repeat: '*',
                nodes: []
              }, {
                type: 'char',
                repeat: '1',
                nodes: [';']
              }
            ]
          }
        ]
      });
      this.register('or', function(ast) {
        return function(ast) {
          if (ast.type === 'undefined') {
            ast.type = 'or';
            return null;
          }
          if (ast.type === 'or') {
            return null;
          }
          return null;
        };
      });
      this.register('not', function(ast) {
        return function() {
          if (ast.type === 'undefined') {
            ast.type = 'or';
          }
          return this.goingForNot = true;
        };
      });
      this.register('and', function(ast) {
        return function(ast) {
          if (ast.type === 'undefined') {
            ast.type = 'and';
            return null;
          }
          if (ast.type === 'and') {
            return null;
          }
          return null;
        };
      });
      this.register('id', function(ast, cap) {
        var node, notNode;

        node = new Object;
        node.type = 'sub';
        node.repeat = '1';
        node.ast = null;
        node.cap = null;
        node.nodes = new Array;
        node.nodes.push(cap);
        if (this.lastAst !== null) {
          node.ast = this.lastAst;
          this.lastAst = null;
        }
        if (this.lastCap !== null) {
          if (this.capToField === true) {
            node.capField = true;
            this.capToField = false;
          }
          node.cap = this.lastCap;
          this.lastCap = null;
        }
        if (this.goingForNot === true) {
          this.goingForNot = false;
          notNode = this.createNotNode();
          notNode.nodes.push(node);
          return notNode;
        }
        return node;
      });
      this.register('str', function(ast, cap) {
        var i, node, notNode, tmpcap;

        cap = cap.slice(1, -1);
        tmpcap = cap;
        cap = "";
        i = 0;
        while (i < tmpcap.length) {
          if (tmpcap[i] === '\\') {
            i++;
            cap += tmpcap[i];
          } else {
            cap += tmpcap[i];
          }
          ++i;
        }
        node = new Object;
        node.type = 'text';
        node.repeat = '1';
        node.ast = null;
        node.cap = null;
        node.nodes = new Array;
        node.nodes.push(cap);
        if (this.lastAst !== null) {
          node.ast = this.lastAst;
          this.lastAst = null;
        }
        if (this.lastCap !== null) {
          if (this.capToField === true) {
            node.capField = true;
            this.capToField = false;
          }
          node.cap = this.lastCap;
          this.lastCap = null;
        }
        if (this.goingForNot === true) {
          this.goingForNot = false;
          notNode = this.createNotNode();
          notNode.nodes.push(node);
          return notNode;
        }
        return node;
      });
      this.register('group', function(ast) {
        var node;

        node = new Object;
        node.type = 'undefined';
        node.repeat = '1';
        node.ast = null;
        node.cap = null;
        node.nodes = new Array;
        if (this.lastAst !== null) {
          node.ast = this.lastAst;
          this.lastAst = null;
        }
        if (this.lastCap !== null) {
          if (this.capToField === true) {
            node.capField = true;
            this.capToField = false;
          }
          node.cap = this.lastCap;
          this.lastCap = null;
        }
        if (this.goingForNot === true) {
          this.goingForNot = false;
          node.type = 'not';
        }
        return node;
      });
      this.register('rule', function(ast) {
        return function(ast) {
          if (ast.type === 'undefined') {
            ast.type = 'and';
          }
          return null;
        };
      });
      this.register('closing_group', function(ast) {
        if (ast.type === 'undefined') {
          ast.type = 'and';
        }
        return null;
      });
      this.register('repeater', function(ast, cap) {
        var last;

        if (ast.nodes.length < 1) {
          throw "Can't set repeater '" + cap + "'";
        }
        last = ast.nodes.slice(-1)[0];
        if (last.type === 'not') {
          last = last.nodes[0];
        }
        last.repeat = cap;
        return null;
      });
      this.register('cap', function(ast, cap) {
        this.lastCap = cap.slice(0, -1);
        return null;
      });
      this.register('capstr', function(ast, cap) {
        this.lastCap = cap;
        return null;
      });
      this.register('capfield', function(ast, cap) {
        if (cap.length === 1) {
          this.capToField = true;
        } else {
          this.capToField = false;
        }
        return null;
      });
      this.register('ast', function(ast, cap) {
        this.lastAst = cap.slice(0, -1);
        return null;
      });
      this.register('newrule', function(ast) {
        var node;

        node = new Object;
        node.name = 'nil';
        node.nodes = new Array;
        return node;
      });
      this.register('rulename', function(ast, name) {
        ast.name = name;
        return null;
      });
      this.register('rulecore', function(ast, name) {
        var node;

        node = new Object;
        node.type = 'undefined';
        node.repeat = '1';
        node.ast = null;
        node.cap = null;
        node.nodes = new Array;
        return node;
      });
      return this.register('keyword', function(ast, keyword) {
        var node, notNode;

        node = new Object;
        node.type = keyword;
        node.repeat = '1';
        node.ast = null;
        node.cap = null;
        node.nodes = new Array;
        if (this.lastAst !== null) {
          node.ast = this.lastAst;
          this.lastAst = null;
        }
        if (this.lastCap !== null) {
          if (this.capToField === true) {
            node.capField = true;
            this.capToField = false;
          }
          node.cap = this.lastCap;
          this.lastCap = null;
        }
        if (this.goingForNot === true) {
          this.goingForNot = false;
          notNode = this.createNotNode();
          notNode.nodes.push(node);
          return notNode;
        }
        return node;
      });
    };

    return GrammarParser;

  })(AstParser);

  YParser = (function(_super) {
    __extends(YParser, _super);

    function YParser() {
      YParser.__super__.constructor.call(this);
    }

    return YParser;

  })(AstParser);

  YParser.SimpleParser = SimpleParser;

  YParser.ExtendedParser = ExtendedParser;

  YParser.AstParser = AstParser;

  YParser.GrammarParser = GrammarParser;

  module.exports = YParser;

}).call(this);

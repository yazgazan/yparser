// Generated by CoffeeScript 1.7.1
(function() {
  var Ast, AstToken, YParser, assert;

  YParser = require('../lib/YParser');

  AstToken = YParser.AstToken;

  Ast = YParser.Ast;

  assert = function(expected, actual) {
    var err;
    if ((expected !== void 0) && (actual !== void 0)) {
      if (expected === actual) {
        return;
      }
    }
    err = new Error;
    err.expected = "" + expected;
    err.actual = "" + actual;
    throw err;
  };

  describe("AstToken", function() {
    return it("should construct a copy of the token. Only type and data should appear in JSON", function() {
      var baseToken, token;
      baseToken = {
        type: 'id',
        data: 'test',
        line: 42,
        pos: 23,
        garbageData: 'haha'
      };
      token = new AstToken(baseToken);
      assert('id', token.type);
      assert('test', token.data);
      assert(42, token.line());
      assert(23, token.pos());
      assert("" + void 0, "" + token.garbageData);
      return assert('haha', token.token().garbageData);
    });
  });

  describe("Ast", function() {
    describe("#construct", function() {
      return it("should construct a clean ast node", function() {
        var node;
        node = new Ast;
        assert(null, node.type);
        assert(0, node.nodes.length);
        node = new Ast("node_type");
        assert("node_type", node.type);
        return assert(0, node.nodes.length);
      });
    });
    describe("#new", function() {
      return it("should create a new Ast node, add it to nodes and return it", function() {
        var node, subnode;
        node = new Ast;
        subnode = node["new"]("test");
        assert(1, node.nodes.length);
        assert("test", subnode.type);
        return assert(0, subnode.nodes.length);
      });
    });
    return describe("#addToken", function() {
      return it("should create a new AstToken from token and push it to nodes. return the AstToken", function() {
        var baseToken, node, token;
        baseToken = {
          type: 'id',
          data: 'test',
          line: 42,
          pos: 23,
          garbageData: 'haha'
        };
        node = new Ast;
        token = node.addToken(baseToken);
        assert(1, node.nodes.length);
        assert('id', token.type);
        assert('test', token.data);
        assert(42, token.line());
        assert(23, token.pos());
        assert("" + void 0, "" + token.garbageData);
        return assert('haha', token.token().garbageData);
      });
    });
  });

  describe("YParser", function() {
    describe("#constructor", function() {
      return it("should construct a clean YParser", function() {
        var parser;
        parser = new YParser;
        assert("", parser.buff);
        assert(0, parser.pos);
        assert(1, parser.line);
        assert(1, parser.cpos);
        assert(false, parser.breakOnUnknownToken);
        return assert(0, parser.tokens.length);
      });
    });
    describe("#init", function() {
      return it("should load s if any, create  a root node and tokenize the string", function() {
        var parser, test_str;
        test_str = "toto  ha42 blah";
        parser = new YParser;
        parser.addTokRule("id", function() {
          return this.readIdentifier();
        });
        parser.addTokRule("spaces", function() {
          return this.readSpaces();
        });
        parser.init(test_str);
        assert('id', parser.tokens[0].type);
        assert('toto', parser.tokens[0].data);
        assert(1, parser.tokens[0].line);
        assert(1, parser.tokens[0].pos);
        assert('spaces', parser.tokens[1].type);
        assert(1, parser.tokens[1].line);
        assert(5, parser.tokens[1].pos);
        assert('id', parser.tokens[2].type);
        assert('ha42', parser.tokens[2].data);
        assert(1, parser.tokens[2].line);
        assert(7, parser.tokens[2].pos);
        assert('spaces', parser.tokens[3].type);
        assert(1, parser.tokens[3].line);
        assert(11, parser.tokens[3].pos);
        assert('id', parser.tokens[4].type);
        assert('blah', parser.tokens[4].data);
        assert(1, parser.tokens[4].line);
        return assert(12, parser.tokens[4].pos);
      });
    });
    describe("#peekToken", function() {
      return it("should return the token if next token is of type `type`, returns null otherwise. returns the next token if no type provided", function() {
        var parser, test_str, token;
        test_str = "toto  ha42 blah";
        parser = new YParser;
        parser.addTokRule("id", function() {
          return this.readIdentifier();
        });
        parser.addTokRule("spaces", function() {
          return this.readSpaces();
        });
        parser.init(test_str);
        token = parser.peekToken('id');
        assert(true, token !== null);
        assert('id', token.type);
        ++parser.curToken;
        token = parser.peekToken('id');
        assert(null, token);
        token = parser.peekToken('spaces');
        assert(true, token !== null);
        assert('spaces', token.type);
        ++parser.curToken;
        token = parser.peekToken();
        assert(true, token !== null);
        return assert('id', token.type);
      });
    });
    describe("#getToken", function() {
      return it("should work like peekToken but move curToken to the next token", function() {
        var parser, test_str, token;
        test_str = "toto  ha42 blah";
        parser = new YParser;
        parser.addTokRule("id", function() {
          return this.readIdentifier();
        });
        parser.addTokRule("spaces", function() {
          return this.readSpaces();
        });
        parser.init(test_str);
        token = parser.getToken('id');
        assert(true, token !== null);
        assert('id', token.type);
        token = parser.getToken('id');
        assert(null, token);
        token = parser.getToken('spaces');
        assert(true, token !== null);
        assert('spaces', token.type);
        token = parser.getToken();
        assert(true, token !== null);
        return assert('id', token.type);
      });
    });
    describe("#isEndToken", function() {
      return it("should return true if all token are read, returns false otherwise", function() {
        var parser, test_str;
        test_str = "toto  ha42 blah";
        parser = new YParser;
        parser.addTokRule("id", function() {
          return this.readIdentifier();
        });
        parser.addTokRule("spaces", function() {
          return this.readSpaces();
        });
        parser.init(test_str);
        assert(false, parser.isEndToken());
        parser.getToken();
        assert(false, parser.isEndToken());
        parser.getToken();
        assert(false, parser.isEndToken());
        parser.getToken();
        assert(false, parser.isEndToken());
        parser.getToken();
        assert(false, parser.isEndToken());
        parser.getToken();
        return assert(true, parser.isEndToken());
      });
    });
    describe("#addRule", function() {
      return it("should register the given parsing rule", function() {
        var parser;
        parser = new YParser;
        assert(42, parser.addRule('test', 42));
        return assert(42, parser.rules['test']);
      });
    });
    describe("#_readToken", function() {
      return it("should consume and return true if peekToken isnt null, false otherwise", function() {
        var parser, test_str;
        test_str = "toto  ha42 blah";
        parser = new YParser;
        parser.addTokRule("id", function() {
          return this.readIdentifier();
        });
        parser.addTokRule("spaces", function() {
          return this.readSpaces();
        });
        parser.init(test_str);
        assert(true, parser._readToken('id'));
        assert(false, parser._readToken('id'));
        assert(true, parser._readToken('spaces'));
        return assert(true, parser._readToken());
      });
    });
    describe("#repeat", function() {
      describe("'1'", function() {
        return it("should return like func, func is called only once", function() {
          var parser;
          parser = new YParser;
          assert(true, parser.repeat("1", function() {
            return true;
          }));
          return assert(false, parser.repeat("1", function() {
            return false;
          }));
        });
      });
      describe("'?'", function() {
        return it("should return true on any cases, func is called only once", function() {
          var parser;
          parser = new YParser;
          assert(true, parser.repeat("?", function() {
            return true;
          }));
          return assert(true, parser.repeat("?", function() {
            return false;
          }));
        });
      });
      describe("'*'", function() {
        return it("should return true on any cases, func is called as long as it returns true", function() {
          var i, parser;
          parser = new YParser;
          i = 0;
          assert(true, parser.repeat("*", function() {
            ++i;
            if (i >= 10) {
              return false;
            }
            return true;
          }));
          assert(10, i);
          i = 0;
          assert(true, parser.repeat("*", function() {
            ++i;
            if (i > 0) {
              return false;
            }
            return true;
          }));
          return assert(1, i);
        });
      });
      return describe("'+'", function() {
        return it("should return true if func returns true at least on first call, func is called as long as it returns true", function() {
          var i, parser;
          parser = new YParser;
          i = 0;
          assert(true, parser.repeat("+", function() {
            ++i;
            if (i >= 10) {
              return false;
            }
            return true;
          }));
          assert(10, i);
          i = 0;
          assert(false, parser.repeat("+", function() {
            ++i;
            if (i > 0) {
              return false;
            }
            return true;
          }));
          return assert(1, i);
        });
      });
    });
    describe("#readToken", function() {
      return it("should read the given token, given the repeater, returns like repeat", function() {
        var parser, test_str;
        test_str = "aaabbbd";
        parser = new YParser;
        parser.addTokRule("a", function() {
          return this.readChar('a');
        });
        parser.addTokRule("b", function() {
          return this.readChar('b');
        });
        parser.addTokRule("c", function() {
          return this.readChar('c');
        });
        parser.addTokRule("d", function() {
          return this.readChar('d');
        });
        parser.init(test_str);
        assert(true, parser.readToken('a', '1'));
        assert(false, parser.readToken('b', '1'));
        assert(true, parser.readToken('a', '*'));
        assert(false, parser.readToken('a', '1'));
        assert(true, parser.readToken('a', '*'));
        assert(true, parser.readToken('b', '+'));
        assert(false, parser.readToken('b', '+'));
        assert(true, parser.readToken('b', '?'));
        return assert(true, parser.readToken('d', '?'));
      });
    });
    describe("#parse", function() {
      describe("no ast", function() {
        return it("should parse the string using the given the entry rule", function() {
          var parser, test_str;
          test_str = "(print test toto 42)";
          parser = new YParser;
          parser.addTokRule('PARO', function() {
            return this.readChar('(');
          });
          parser.addTokRule('PARC', function() {
            return this.readChar(')');
          });
          parser.addTokRule('id', function() {
            return this.readIdentifier();
          });
          parser.addTokRule('int', function() {
            return this.readInt();
          });
          parser.addTokRule('spaces', function() {
            return this.readSpaces();
          });
          parser.addRule("main", function() {
            this.getToken('spaces');
            if (!this.readToken('PARO')) {
              return false;
            }
            if (!this.parse("tokens")) {
              return false;
            }
            this.getToken('spaces');
            if (!this.readToken('PARC')) {
              return false;
            }
            this.getToken('spaces');
            return true;
          });
          parser.addRule("tokens", function() {
            return this.repeat("*", function() {
              return this.parse("token");
            });
          });
          parser.addRule("token", function() {
            this.getToken('spaces');
            return (this.getToken('id')) || (this.getToken('int'));
          });
          parser.init(test_str);
          assert(true, parser.parse("main"));
          return assert(true, parser.isEndToken());
        });
      });
      return describe("ast", function() {
        return it("should parse the string and build the ast given the entry rule", function() {
          var ast, expectedAst, parser, test_str;
          test_str = "(print test toto (add 42 3) ())";
          parser = new YParser;
          parser.addTokRule('PARO', function() {
            return this.readChar('(');
          });
          parser.addTokRule('PARC', function() {
            return this.readChar(')');
          });
          parser.addTokRule('id', function() {
            return this.readIdentifier();
          });
          parser.addTokRule('int', function() {
            return this.readInt();
          });
          parser.addTokRule('spaces', function() {
            return this.readSpaces();
          });
          parser.addRule("main", function(ast) {
            this.getToken('spaces');
            if (!this.parse("list")) {
              return false;
            }
            this.getToken('spaces');
            return true;
          });
          parser.addRule("list", function(ast) {
            var curAst;
            curAst = new Ast("list");
            if (!this.getToken("PARO")) {
              return false;
            }
            if (!this.parse("tokens", curAst)) {
              return false;
            }
            this.getToken('spaces');
            if (!this.getToken("PARC")) {
              return false;
            }
            ast.nodes.push(curAst);
            return true;
          });
          parser.addRule("tokens", function(ast) {
            return this.repeat("*", function() {
              this.getToken('spaces');
              return this.parse("token", ast);
            });
          });
          parser.addRule("token", function(ast) {
            return (this.parse("id", ast)) || (this.parse("int", ast)) || (this.parse("list", ast));
          });
          parser.addRule("id", function(ast) {
            var token;
            token = this.getToken("id");
            if (token === null) {
              return false;
            }
            ast.addToken(token);
            return true;
          });
          parser.addRule("int", function(ast) {
            var token;
            token = this.getToken("int");
            if (token === null) {
              return false;
            }
            ast.addToken(token);
            return true;
          });
          parser.init(test_str);
          assert(true, parser.parse("main"));
          assert(true, parser.isEndToken());
          ast = JSON.stringify(parser.ast);
          expectedAst = "{\"type\":\"root\",\"nodes\":[{\"type\":\"list\",\"nodes\":[{\"type\":\"id\",\"data\":\"print\"},{\"type\":\"id\",\"data\":\"test\"},{\"type\":\"id\",\"data\":\"toto\"},{\"type\":\"list\",\"nodes\":[{\"type\":\"id\",\"data\":\"add\"},{\"type\":\"int\",\"data\":\"42\"},{\"type\":\"int\",\"data\":\"3\"}]},{\"type\":\"list\",\"nodes\":[]}]}]}";
          return assert(expectedAst, ast);
        });
      });
    });
    return describe("#recreateLine", function() {
      return it("should recreate the line where the given token can be found", function() {
        var node, parser, test_str;
        test_str = "(print test toto (add 42 3) ())";
        parser = new YParser;
        parser.addTokRule('PARO', function() {
          return this.readChar('(');
        });
        parser.addTokRule('PARC', function() {
          return this.readChar(')');
        });
        parser.addTokRule('id', function() {
          return this.readIdentifier();
        });
        parser.addTokRule('int', function() {
          return this.readInt();
        });
        parser.addTokRule('spaces', function() {
          return this.readSpaces();
        });
        parser.addRule("main", function(ast) {
          this.getToken('spaces');
          if (!this.parse("list")) {
            return false;
          }
          this.getToken('spaces');
          return true;
        });
        parser.addRule("list", function(ast) {
          var curAst;
          curAst = new Ast("list");
          if (!this.getToken("PARO")) {
            return false;
          }
          if (!this.parse("tokens", curAst)) {
            return false;
          }
          this.getToken('spaces');
          if (!this.getToken("PARC")) {
            return false;
          }
          ast.nodes.push(curAst);
          return true;
        });
        parser.addRule("tokens", function(ast) {
          return this.repeat("*", function() {
            this.getToken('spaces');
            return this.parse("token", ast);
          });
        });
        parser.addRule("token", function(ast) {
          return (this.parse("id", ast)) || (this.parse("int", ast)) || (this.parse("list", ast));
        });
        parser.addRule("id", function(ast) {
          var token;
          token = this.getToken("id");
          if (token === null) {
            return false;
          }
          ast.addToken(token);
          return true;
        });
        parser.addRule("int", function(ast) {
          var token;
          token = this.getToken("int");
          if (token === null) {
            return false;
          }
          ast.addToken(token);
          return true;
        });
        parser.init(test_str);
        assert(true, parser.parse("main"));
        assert(true, parser.isEndToken());
        node = parser.ast.nodes[0].nodes[2];
        return assert(test_str, parser.recreateLine(node));
      });
    });
  });

}).call(this);

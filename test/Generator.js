// Generated by CoffeeScript 1.7.1
(function() {
  var Generator, assert, bnf0, bnf1, bnf2, bnf3, bnf4, bnf5, bnf6;

  Generator = require('../lib/Generator');

  assert = function(expected, actual) {
    var err;
    if ((expected !== void 0) && (actual !== void 0)) {
      if (expected === actual) {
        return;
      }
    }
    err = new Error;
    err.expected = "" + expected;
    err.actual = "" + actual;
    throw err;
  };

  bnf0 = "\nid = id ;\nspaces = spaces ;\n\nmain :: [spaces? id]+ spaces? eof\n  ;\n";

  bnf1 = "\nid = id ;\nspaces = spaces ;\n\nmain :: [spaces? id:id]+ spaces? eof\n  ;\n";

  bnf2 = "\nid = id ;\nspaces = spaces ;\nPO = '(' ;\nPC = ')' ;\n\nmain :: list* spaces? eof\n  ;\n\nlist ::\n  spaces? PO\n  [spaces? id]*\n  spaces? !PC\n  ;\n";

  bnf3 = "\nid = id ;\nspaces = spaces ;\nPO = '(' ;\nPC = ')' ;\n\nmain :: list* spaces? eof\n  ;\n\nlist ::\n  list#[\n    spaces? PO\n    spaces? .id:id?\n    [spaces? id:id]*\n    spaces? !PC\n  ]\n  ;\n";

  bnf4 = "\nid = id ;\nint = int ;\nstr = '\"' [['\\\\\"' | any] ^ '\"']* '\"' ;\nspaces = spaces ;\nPO = '(' ;\nPC = ')' ;\n\nmain :: token* spaces? eof\n  ;\n\nlist ::\n  PO\n  .id:id?\n  token*\n  spaces? !PC\n  ;\n\ntoken::\n  spaces?\n  [\n      list#list\n    | id:id\n    | int(toNumber):int\n    | str(cleanStr):str\n  ]\n  ;\n";

  bnf5 = "\nid = id ;\nint = int ;\nstr = '\"' [['\\\\\"' | any] ^ '\"']* '\"' ;\nspaces = spaces ;\nPO = '(' ;\nPC = ')' ;\nHO = '[' ;\nHC = ']' ;\n\nmain :: token* spaces? eof\n  ;\n\nlist ::\n  PO\n  .id:token?\n  token*\n  spaces? !PC\n  ;\n\nhash ::\n  HO\n  [duet#duet]*\n  spaces? !HC\n  ;\n\nduet ::\n  token\n  !token\n  ;\n\ntoken::\n  spaces?\n  [\n      list#list\n    | hash#hash\n    | id:id\n    | int(toNumber):int\n    | str(cleanStr):str\n  ]\n  ;\n";

  bnf6 = "\nid = id ;\nint = int ;\nstr = '\"' [['\\\\\"' | any] ^ '\"']* '\"' ;\nspaces = spaces ;\nPO = '(' ;\nPC = ')' ;\nHO = '[' ;\nHC = ']' ;\n\nmain :: token* spaces? eof\n  ;\n\nlist ::\n  PO\n  .id:token?\n  token*\n  spaces? !PC\n  ;\n\nhash ::\n  HO\n  [duet#duet]*\n  spaces? !HC\n  ;\n\nduet ::\n  @token_key\n  token\n  !token\n  ;\n\ntoken ::\n  spaces?\n  [\n      list#list\n    | hash#hash\n    | id:id\n    | int(toNumber):int\n    | str(cleanStr):str\n  ]\n  ;\n\ntoken_key ::\n  spaces?\n  [\n    .key:id\n    | .key(toNumber):int\n    | .key(cleanStr):str\n  ]\n  ;\n";

  describe("Generator", function() {
    describe("#constructor", function() {
      return it("should construct a generator, parsing the bnf", function() {
        var parser;
        parser = new Generator(bnf0);
        return assert(true, parser.ast.nodes.length > 0);
      });
    });
    return describe("#generate", function() {
      describe("0", function() {
        var generator, test_str;
        test_str = "haha hihi blah test toto";
        generator = new Generator(bnf0);
        return it("should parse the string without errors", function() {
          var parser;
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          assert(true, parser.parse());
          return assert(0, parser.ast.nodes.length);
        });
      });
      describe("1", function() {
        var res, test_str;
        test_str = "haha hihi blah test toto";
        res = ["haha", "hihi", "blah", "test", "toto"];
        return it("should parse the string with captures", function() {
          var generator, id, parser, token, _i, _len, _ref, _results;
          generator = new Generator(bnf1);
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          assert(true, parser.parse());
          assert(5, parser.ast.nodes.length);
          _ref = parser.ast.nodes;
          _results = [];
          for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
            token = _ref[id];
            assert(res[id], token.data);
            _results.push(assert("id", token.type));
          }
          return _results;
        });
      });
      describe("2", function() {
        var test_str;
        test_str = "(ha hi ho) (blah toto)";
        return it("should parse the string with sub-rule", function() {
          var generator, parser;
          generator = new Generator(bnf2);
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          return assert(true, parser.parse());
        });
      });
      describe("3", function() {
        var expected, test_str;
        test_str = "(ha hi ho) (blah toto)";
        expected = "{\"type\":\"root\",\"nodes\":[{\"type\":\"list\",\"nodes\":[{\"type\":\"id\",\"data\":\"hi\"},{\"type\":\"id\",\"data\":\"ho\"}],\"id\":\"ha\"},{\"type\":\"list\",\"nodes\":[{\"type\":\"id\",\"data\":\"toto\"}],\"id\":\"blah\"}]}";
        return it("should build an ast tree with captures", function() {
          var generator, parser;
          generator = new Generator(bnf3);
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          assert(true, parser.parse());
          return assert(expected, JSON.stringify(parser.ast));
        });
      });
      describe("4", function() {
        var expected, test_str;
        test_str = '(ha (42 toto "hey") "blah\\"titi")';
        expected = "{\"type\":\"root\",\"nodes\":[{\"type\":\"list\",\"nodes\":[{\"type\":\"list\",\"nodes\":[{\"type\":\"int\",\"data\":42},{\"type\":\"id\",\"data\":\"toto\"},{\"type\":\"str\",\"data\":\"hey\"}],\"id\":\"\"},{\"type\":\"str\",\"data\":\"blah\\\"titi\"}],\"id\":\"ha\"}]}";
        return it("should build an ast tree with nested lists and complex tokens (str) and hooks", function() {
          var generator, parser;
          generator = new Generator(bnf4);
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          assert(true, parser.parse());
          return assert(expected, JSON.stringify(parser.ast));
        });
      });
      describe("5", function() {
        var expected, test_str;
        test_str = '(ha (42 toto "hey") "blah\\"titi" [ 1 2 5 3])';
        expected = "{\"type\":\"root\",\"nodes\":[{\"type\":\"list\",\"nodes\":[{\"type\":\"id\",\"data\":\"ha\"},{\"type\":\"list\",\"nodes\":[{\"type\":\"int\",\"data\":42},{\"type\":\"id\",\"data\":\"toto\"},{\"type\":\"str\",\"data\":\"hey\"}],\"id\":\"42\"},{\"type\":\"str\",\"data\":\"blah\\\"titi\"},{\"type\":\"hash\",\"nodes\":[{\"type\":\"duet\",\"nodes\":[{\"type\":\"int\",\"data\":1},{\"type\":\"int\",\"data\":2}]},{\"type\":\"duet\",\"nodes\":[{\"type\":\"int\",\"data\":5},{\"type\":\"int\",\"data\":3}]}]}],\"id\":\"ha\"}]}";
        return it("should build an ast tree, with nested lists/hash", function() {
          var generator, parser;
          generator = new Generator(bnf5);
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          assert(true, parser.parse());
          return assert(expected, JSON.stringify(parser.ast));
        });
      });
      return describe("6", function() {
        var expected, test_str;
        test_str = '["ha" 42 "ho" 23] [1 2 5 3]';
        expected = "{\"type\":\"root\",\"nodes\":[{\"type\":\"hash\",\"nodes\":[{\"type\":\"duet\",\"nodes\":[{\"type\":\"str\",\"data\":\"ha\"},{\"type\":\"int\",\"data\":42}],\"key\":\"ha\"},{\"type\":\"duet\",\"nodes\":[{\"type\":\"str\",\"data\":\"ho\"},{\"type\":\"int\",\"data\":23}],\"key\":\"ho\"}]},{\"type\":\"hash\",\"nodes\":[{\"type\":\"duet\",\"nodes\":[{\"type\":\"int\",\"data\":1},{\"type\":\"int\",\"data\":2}],\"key\":1},{\"type\":\"duet\",\"nodes\":[{\"type\":\"int\",\"data\":5},{\"type\":\"int\",\"data\":3}],\"key\":5}]}]}";
        return it("should build an ast tree, with nested lists/hash, and peek support", function() {
          var generator, parser;
          generator = new Generator(bnf6);
          parser = generator.generate();
          parser.loadString(test_str);
          parser.init();
          assert(true, parser.parse());
          return assert(expected, JSON.stringify(parser.ast));
        });
      });
    });
  });

}).call(this);

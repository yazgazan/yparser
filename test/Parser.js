// Generated by CoffeeScript 1.7.1
(function() {
  var Parser, assert;

  Parser = require('../lib/Parser');

  assert = function(expected, actual) {
    var err;
    if ((expected !== void 0) && (actual !== void 0)) {
      if (expected === actual) {
        return;
      }
    }
    err = new Error;
    err.expected = "" + expected;
    err.actual = "" + actual;
    throw err;
  };

  describe("Parser", function() {
    describe("#constructor", function() {
      return it("should construct a clean parser", function() {
        var parser;
        parser = new Parser;
        assert("", parser.buff);
        assert(0, parser.pos);
        assert(1, parser.line);
        return assert(1, parser.cpos);
      });
    });
    describe("#loadString", function() {
      return it("should initialize buffer and pos", function() {
        var parser, test_str;
        test_str = "toto";
        parser = new Parser;
        if ((parser.loadString(test_str)) !== 0) {
          assert();
        }
        return assert(test_str, parser.buff);
      });
    });
    describe("#consume", function() {
      return it("should move pos n (default to 1)", function() {
        var parser, test_str;
        test_str = "toto";
        parser = new Parser;
        parser.loadString(test_str);
        if (parser.consume() !== 1) {
          assert();
        }
        assert(1, parser.pos);
        if (parser.consume(2) !== 3) {
          assert();
        }
        return assert(3, parser.pos);
      });
    });
    describe("#remaining", function() {
      return it("should return the remaining chars in buff", function() {
        var parser, test_str;
        test_str = "toto";
        parser = new Parser;
        parser.loadString(test_str);
        parser.consume();
        return assert("oto", parser.remaining());
      });
    });
    describe("#isEnd", function() {
      return it("should return true if pos >= buff.length", function() {
        var parser, test_str;
        test_str = "ab";
        parser = new Parser;
        parser.loadString(test_str);
        assert(false, parser.isEnd());
        parser.consume();
        assert(false, parser.isEnd());
        parser.consume();
        return assert(true, parser.isEnd());
      });
    });
    describe("#startCap", function() {
      return it("should initialize a cap in @caps", function() {
        var cap_name, parser, test_str;
        test_str = "toto";
        cap_name = "testcap";
        parser = new Parser;
        parser.loadString(test_str);
        parser.consume();
        if ((parser.startCap(cap_name)) !== 1) {
          assert();
        }
        return assert(1, parser.caps[cap_name]);
      });
    });
    describe("#endCap", function() {
      return it("should return captured data", function() {
        var cap, cap_name, parser, test_str;
        test_str = "toto";
        cap_name = "testcap";
        parser = new Parser;
        parser.loadString(test_str);
        parser.consume();
        parser.startCap(cap_name);
        parser.consume();
        parser.consume();
        cap = parser.endCap(cap_name);
        return assert("ot", cap);
      });
    });
    describe("#endCap", function() {
      return it("should return empty cap when no chars consumed", function() {
        var cap, cap_name, parser, test_str;
        test_str = "toto";
        cap_name = "testcap";
        parser = new Parser;
        parser.loadString(test_str);
        parser.consume();
        parser.startCap(cap_name);
        cap = parser.endCap(cap_name);
        return assert("", cap);
      });
    });
    describe("#peekChar", function() {
      return it("should return false if isEnd or if c doesn't match char at @pos", function() {
        var parser, ret, test_str;
        test_str = "toto";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekChar('t');
        assert(true, ret);
        ret = parser.peekChar('k');
        assert(false, ret);
        parser.consume();
        parser.consume();
        parser.consume();
        ret = parser.peekChar('o');
        assert(true, ret);
        parser.consume();
        ret = parser.peekChar('d');
        return assert(false, ret);
      });
    });
    describe("#peekRange", function() {
      return it("should return false if isEnd or if c isnt between start and end", function() {
        var parser, ret, test_str;
        test_str = "toto";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekRange('a', 'z');
        assert(true, ret);
        ret = parser.peekRange('a', 'k');
        assert(false, ret);
        parser.consume();
        parser.consume();
        parser.consume();
        ret = parser.peekRange('n', 'q');
        assert(true, ret);
        parser.consume();
        ret = parser.peekRange('a', 'z');
        return assert(false, ret);
      });
    });
    describe("#peekText", function() {
      return it("should return true if text match, false if @pos + s.length > @buff.length", function() {
        var parser, ret, test_str;
        test_str = "toto titi tata";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekText('toto');
        assert(true, ret);
        ret = parser.peekText('blah');
        assert(false, ret);
        parser.consume(5);
        ret = parser.peekText('titi');
        assert(true, ret);
        parser.consume(7);
        ret = parser.peekText('titi');
        return assert(false, ret);
      });
    });
    describe("#peekUntil", function() {
      return it("should return n if c is found at pos + n, else return false", function() {
        var parser, ret, test_str;
        test_str = "abcdefgh jkl";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekUntil('c');
        assert(2, ret);
        ret = parser.peekUntil('i');
        assert(false, ret);
        parser.consume(3);
        ret = parser.peekUntil('c');
        return assert(false, ret);
      });
    });
    describe("#peekAny", function() {
      return it("should return true if not isEnd", function() {
        var parser, ret, test_str;
        test_str = "abc";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekAny();
        assert(true, ret);
        parser.consume(2);
        ret = parser.peekAny();
        assert(true, ret);
        parser.consume(1);
        ret = parser.peekAny();
        return assert(false, ret);
      });
    });
    describe("#peekAlpha", function() {
      return it("should return true if current char is in ranges a..z or A..Z", function() {
        var parser, ret, test_str;
        test_str = "a2B*";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekAlpha();
        assert(true, ret);
        parser.consume();
        ret = parser.peekAlpha();
        assert(false, ret);
        parser.consume();
        ret = parser.peekAlpha();
        assert(true, ret);
        parser.consume();
        ret = parser.peekAlpha();
        assert(false, ret);
        parser.consume();
        ret = parser.peekAlpha();
        return assert(false, ret);
      });
    });
    describe("#peekAlpha", function() {
      return it("should return true if current char is in ranges 0..9", function() {
        var parser, ret, test_str;
        test_str = "2a4*";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekNum();
        assert(true, ret);
        parser.consume();
        ret = parser.peekNum();
        assert(false, ret);
        parser.consume();
        ret = parser.peekNum();
        assert(true, ret);
        parser.consume();
        ret = parser.peekNum();
        assert(false, ret);
        parser.consume();
        ret = parser.peekNum();
        return assert(false, ret);
      });
    });
    describe("#peekAlphaNum", function() {
      return it("should return true if current char is in ranges 0..9", function() {
        var parser, ret, test_str;
        test_str = "2a4*";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekAlphaNum();
        assert(true, ret);
        parser.consume();
        ret = parser.peekAlphaNum();
        assert(true, ret);
        parser.consume();
        ret = parser.peekAlphaNum();
        assert(true, ret);
        parser.consume();
        ret = parser.peekAlphaNum();
        assert(false, ret);
        parser.consume();
        ret = parser.peekAlphaNum();
        return assert(false, ret);
      });
    });
    describe("#peekSpace", function() {
      return it("should return true if current char a space (' ' or '\\t')", function() {
        var parser, ret, test_str;
        test_str = " a\tb\n";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekSpace();
        assert(true, ret);
        parser.consume();
        ret = parser.peekSpace();
        assert(false, ret);
        parser.consume();
        ret = parser.peekSpace();
        assert(true, ret);
        parser.consume();
        ret = parser.peekSpace();
        assert(false, ret);
        parser.consume();
        ret = parser.peekSpace();
        assert(false, ret);
        parser.consume();
        ret = parser.peekSpace();
        assert(false, ret);
        return parser.consume();
      });
    });
    describe("#peekAll", function() {
      return it("should return false if isEnd", function() {
        var parser, ret, test_str;
        test_str = "abc";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.peekAll();
        assert(true, ret);
        parser.consume(3);
        ret = parser.peekAll();
        return assert(false, ret);
      });
    });
    describe("#readChar", function() {
      return it("should consume 1 char if peekChar returns true. Returns like peekChar", function() {
        var parser, ret, test_str;
        test_str = "abc";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readChar('a');
        assert(true, ret);
        ret = parser.readChar('a');
        assert(false, ret);
        ret = parser.readChar('b');
        assert(true, ret);
        ret = parser.readChar('c');
        assert(true, ret);
        ret = parser.readChar('c');
        return assert(false, ret);
      });
    });
    describe("#readRange", function() {
      return it("should consume 1 char if peekRange returns true. Returns like peekRange", function() {
        var parser, ret, test_str;
        test_str = "abc";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readRange("a", "z");
        assert(true, ret);
        ret = parser.readRange("c", "z");
        assert(false, ret);
        ret = parser.readRange("a", "d");
        assert(true, ret);
        ret = parser.readRange("a", "d");
        assert(true, ret);
        ret = parser.readRange("a", "z");
        return assert(false, ret);
      });
    });
    describe("#readText", function() {
      return it("should consume s.length chars if peekText returns true. returns like peekText", function() {
        var parser, ret, test_str;
        test_str = "toto titi tata";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readText("toto");
        assert(true, ret);
        ret = parser.readText("titi");
        assert(false, ret);
        parser.consume();
        ret = parser.readText("titi");
        assert(true, ret);
        parser.consume();
        parser.consume();
        ret = parser.readText("tata");
        assert(false, ret);
        ret = parser.readText("ata");
        return assert(true, ret);
      });
    });
    describe("#readUntil", function() {
      return it("should consume n chars if peekUntil returns n as a number. returns true if peekUntil returned a number, false otherwise", function() {
        var parser, ret, test_str;
        test_str = "abcd fghij lmnopqr";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readUntil('c');
        assert(true, ret);
        assert(2, parser.pos);
        ret = parser.readUntil('e');
        assert(false, ret);
        assert(2, parser.pos);
        ret = parser.readUntil('l');
        assert(true, ret);
        ret = parser.readUntil('z');
        return assert(false, ret);
      });
    });
    describe("#readAny", function() {
      return it("should consume 1 char if peekAny returns true. returns like peekAny", function() {
        var parser, ret, test_str;
        test_str = "abc";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readAny();
        assert(true, ret);
        ret = parser.readAny();
        assert(true, ret);
        ret = parser.readAny();
        assert(true, ret);
        ret = parser.readAny();
        return assert(false, ret);
      });
    });
    describe("#readAlpha", function() {
      return it("should consume 1 char if peekAlpha returns true. returns like peekAlpha", function() {
        var parser, ret, test_str;
        test_str = "a2B*";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readAlpha();
        assert(true, ret);
        ret = parser.readAlpha();
        assert(false, ret);
        parser.readChar("2");
        ret = parser.readAlpha();
        assert(true, ret);
        ret = parser.readAlpha();
        assert(false, ret);
        parser.readChar("*");
        ret = parser.readAlpha();
        return assert(false, ret);
      });
    });
    describe("#readNum", function() {
      return it("should consume 1 char if peekNum returns true. returns like peekNum", function() {
        var parser, ret, test_str;
        test_str = "2a4*";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readNum();
        assert(true, ret);
        ret = parser.readNum();
        assert(false, ret);
        parser.readChar("a");
        ret = parser.readNum();
        assert(true, ret);
        ret = parser.readNum();
        assert(false, ret);
        parser.readChar("*");
        ret = parser.readNum();
        return assert(false, ret);
      });
    });
    describe("#readAlphaNum", function() {
      return it("should consume 1 char if peekAlphaNum returns true. returns like peekAlphaNum", function() {
        var parser, ret, test_str;
        test_str = "2a4*";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readAlphaNum();
        assert(true, ret);
        ret = parser.readAlphaNum();
        assert(true, ret);
        ret = parser.readAlphaNum();
        assert(true, ret);
        ret = parser.readAlphaNum();
        assert(false, ret);
        parser.readChar("*");
        ret = parser.readAlphaNum();
        return assert(false, ret);
      });
    });
    describe("#readIdentifier", function() {
      return it("should consume and return true if can read an identifier", function() {
        var parser, ret, test_str;
        test_str = "toto42 _ha_21 23a";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readIdentifier();
        assert(true, ret);
        parser.readSpace();
        ret = parser.readIdentifier();
        assert(true, ret);
        parser.readChar(" ");
        ret = parser.readIdentifier();
        assert(false, ret);
        parser.readText("23a");
        ret = parser.readIdentifier();
        return assert(false, ret);
      });
    });
    describe("#readSpace", function() {
      return it("should consume 1 if peekSpace returns true. returns like peekSpace", function() {
        var parser, ret, test_str;
        test_str = " a\t\n";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readSpace();
        assert(true, ret);
        ret = parser.readSpace();
        assert(false, ret);
        parser.readAlpha();
        ret = parser.readSpace();
        assert(true, ret);
        ret = parser.readSpace();
        assert(false, ret);
        parser.readChar("\n");
        ret = parser.readSpace();
        return assert(false, ret);
      });
    });
    describe("#readSpaces", function() {
      return it("should consume next spaces. returns true if any space consumed", function() {
        var parser, ret, test_str;
        test_str = "  a \t b\t\t\n";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readSpaces();
        assert(true, ret);
        ret = parser.readSpaces();
        assert(false, ret);
        parser.readChar('a');
        ret = parser.readSpaces();
        assert(true, ret);
        ret = parser.readSpaces();
        assert(false, ret);
        parser.readChar('b');
        ret = parser.readSpaces();
        assert(true, ret);
        ret = parser.readSpaces();
        assert(false, ret);
        parser.readChar("\n");
        ret = parser.readSpaces();
        return assert(false, ret);
      });
    });
    describe("#readInt", function() {
      return it("should return true if it can read and consume an integer, false otherwise", function() {
        var parser, ret, test_str;
        test_str = "123 456 23a2";
        parser = new Parser;
        parser.loadString(test_str);
        ret = parser.readInt();
        assert(true, ret);
        ret = parser.readInt();
        assert(false, ret);
        parser.readSpace();
        ret = parser.readInt();
        assert(true, ret);
        parser.readSpace();
        ret = parser.readInt();
        assert(true, ret);
        ret = parser.readInt();
        assert(false, ret);
        parser.readChar('a');
        ret = parser.readInt();
        assert(true, ret);
        ret = parser.readInt();
        return assert(false, ret);
      });
    });
    describe("#readEOF", function() {
      return it("should call isEnd and return alike", function() {
        var parser, test_str;
        test_str = "ab";
        parser = new Parser;
        parser.loadString(test_str);
        assert(false, parser.readEOF());
        parser.consume();
        assert(false, parser.readEOF());
        parser.consume();
        return assert(true, parser.readEOF());
      });
    });
    describe("#readEOL", function() {
      return it("should return true if it can consume an end-of-line char ('\\n' or '\\r\\n')", function() {
        var parser, test_str;
        test_str = "\na\r\nb";
        parser = new Parser;
        parser.loadString(test_str);
        assert(true, parser.readEOL());
        assert(false, parser.readEOL());
        parser.readChar("a");
        assert(true, parser.readEOL());
        assert(false, parser.readEOL());
        parser.readChar("b");
        return assert(false, parser.readEOL());
      });
    });
    return describe("#readAll", function() {
      return it("should consume all if peekAll return true. returns like peekAll", function() {
        var parser, test_str;
        test_str = "blah";
        parser = new Parser;
        parser.loadString(test_str);
        assert(true, parser.readAll());
        return assert(false, parser.readAll());
      });
    });
  });

}).call(this);
